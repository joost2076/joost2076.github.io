---
layout: post
title:  "Property Based Testing with Fast-Check"
date:   2023-11-14 07:19:54 +0200
categories: Testing
---


<style>

  @media(min-width:1000px){
    .wrapper{
      max-width:calc(80%);
    }

  }


</style>

## Property Based Testing with Fast-Check

In this post we will try out property based testing in javascript with the [fast-check library](https://fast-check.dev/docs/introduction/).


### What is property based testing ?
In short, a property based tests will generate *lots of random inputs* for the system under test (sut) to act on. Since the inputs are random, the actual outcome of calling the sut on each input is different each time. This means that you will need to *think differently about how to validate the outcome*: you will need to think of properties that hold true for every outcome generated by a range of input, instead of just expecting one fixed outcome for one example. Read on for a longer explanation and the benefits. 

#### Compared to example based testing
A test case is mostly broken up in 3 steps: arrange, act and assert. Simply put, in the arrange step you define your input needed for the test. In the act phase you use the input to do something with the test object. And in the assert phase, you check if the outcome is what you expected. 

The inputs for the test is mostly some smart choice of partitionings and edge cases. And for the assert step you define the literal expected output/error for each test case. For instance one of the test cases for  for a calculate_mean function  is that [1,2,3] outputs 2. The 2 you know to be the right answer 

#### Your job with property based testing
Property based testing does the arrange and the assert different. For the arrange step, no longer do you specify the actual inputs, but instead *you define what constraints the input*: for instance the mean function takes in arrays of numbers (doubles or integers, either positive or negative, with a length of at least 1) . And for the assert step, *you define predicates, or properties that must hold true on the outcome* (for these inputs). This is the harder step. An example property might be that the mean must not be larger then the largest number in the input. Or that when creating inputs that are only positive, the mean must also be positive. Or that the mean of the mean of 2 equal length arrays must be the same as the mean when these 2 arrays are combined.   

We will see ways to find properties soon, but first some more explanation about what is going to happen with the input constraints and properties.

#### The framework does the rest
Now the magic of the property based testing frameworks happens:
- the framework will generate lots of semi-random inputs that match your input constraints for your tests and checks if the property holds true.  
- It will try and find the simplest (combination of) input(s) that triggers failure (if there is one). This is called *shrinking*. All so you have less of a hard time when debugging. 

#### Benefits
The benefits of this include that you will test the sut with way more inputs then you would do in example based testing, making it more likely you will find bugs. 
You will think harder about the inputs under which the sut must work. 
You will think harder about the thing the sut does,leading to a better understanding of your code.  All because thinking of meaningfull properties is not easy and getting them right on the first try might proof though too: you will often need to be more precise. 

That is because one simple example can contain many implicit assumptions, that when you need to explicate those are rather tricky to get right and write down. And because throwing more inputs at your tests, will make it more important to think about when it should work. You can read a lot more [here](https://increment.com/testing/in-praise-of-property-based-testing/).


### How to find good properties ?
So lets discuss some way to think about how to come up with properties. This is the hard part, but also the part were you learn the most about your code. The following is mostly based of this [blog](https://www.innoq.com/en/articles/2023/04/testing-fast-check/) which mentions this [article](https://research.chalmers.se/publication/517894/file/517894_Fulltext.pdf) and a [blog](https://medium.com/@nicolasdubien/find-the-best-properties-for-property-based-testing-ee2ed9d442e1) by the fastcheck author.

The most obvious one would be *correctness* of the output. Is the literal output what you actually expect ?
- some type of problems are hard to calculate but easy to check. For any sorting algo it is easy to check if the output is actually in sorted order (for each item is smaller then the next one) and each item is in the output . This is always a good property. 
- sometimes there is a different implementation around (that is slower / more memory intensive / in another language) that you can use to to check the output of the new implementation. 

Correctness is not always feasible to check in a direct way for every input without rewriting the sut, but you can try the following:  
- you might not know the exact output, but you do know that certain inputs must generate one specific outcome. For instance when testing a correlation function, an array is always fully correlated with itself and hence must output 1. Or when you test multiplication, the output must always be 0 if one of the inputs is 0. 
- Properties can be found by focussing on some characteristis of output (mean of negative numbers must also be negative ).   
- Or you could more generally say the output must always be between some range (for instance 0 and 1). Or always an error for illegal inputs.  Or that there is always a valid output. Though they may feel somewhat silly, I feel it is a great sanity check. 
- sometimes the order of inputs should not matter. Changing the order then should still produce the same output.

One step further you can think about expecting stuff about the output over multiple calls:
- Maybe each output must be unique. there should be no 2 outputs that generate the same outcome.
- a whole range of inputs should include n outputs of certain type: see this [fizzbuzz](Read about the properties to test for with the fizzbuzz problem. https://blog.ploeh.dk/2021/06/28/property-based-testing-is-not-the-same-as-partition-testing/
) example


Property based testing is infused with invariants: generally defined as properties if the class or data structure or problem that must hold true always. They are different then the above, because they do not deal directly with the output of the procedure.  
-  It might also be important to check that the input or state used is left as it was. Did the sorting leave the input unchanged ? Did inserting a node leave al the others in the right place ? 
- maybe some other ways might be test whether you are closing in on some limit or better score. For instance, forever multiplying more and more numbers between -1 and 1 should get closer and closer to 0. 


*Metamorphic*  are another way to go about deriving properties. Do some transformation on the inputs for wich you know the output should stay fixed or change in some easily transformable way. By doing a second thing to the input, something predictable happens:
- If there is an inverse function (like division and multiplication, encode/decode) calling both consecutive with some input should return to the original input. A path through a maze in reverse order started from the endpoint should return you to the startpoint.  
- you might not know the exact answer to a linear regression (ax+b) but you do know that translating each input with {x:0,y:2} should move the b by 2. A clustering algorithm (deterministic or seeded the same) should calculate the same clusters centers + translation after translating the inputs. 
- repeated calls do not change the result if 'idempotent'


*Simplification*
 you can make a model that simplifies some part of the problem (possibly for some specific input contraints), 
- if the actual function is some simple logic or math hidden in some more usefull class with lots of input parameters and conditionals, a rather simple model for which you might re-implement part (under a range of inputs) might do.
- There is also [model based testing](https://fast-check.dev/docs/advanced/model-based-testing/). This is actually sidestepping a bit from property based testing. With model based testing fc (or any other model based framework) executes possible actions in the sut and in a simplified model and compares the results. 


There are some great [examples](https://github.com/dubzzz/fast-check/tree/main/examples) in the fast-check github repo to study. But I recommend you try out some examples yourself. In the rest of this post you can find my tryouts of writing tests with fastcheck. It will show some examples of how to setup tests  and some explanation about how to think of properties. But first, some more explanation about the terminology and the fastcheck api. 


### the terminology and setup: arbitraries, properties and runners
Most important part to start with are the *arbitraries*. Arbitraries generate the random inputs. There are arbitraries for atomic types such as numbers and strings, and for any combination of those in arrays or objects. There are also arbitraries for specific stuff like weburls, ip-adresses, json, base64 strings, or strings matching some regex and so on. All of these can be combined, restrained or adjusted to satisfy your testing needs. 

Next up: the property.  A *property* consists of a number of arbitraries and a predicate. The predicate is a function that returns true or false, and this particular predicate function should have the arbitraries you generated as inputs, and inside it should 'act' upon the thing you are testing. The predicate cointains the actual test and its output should always be true.   

And finally fastcheck provides runners. The main runner is called *assert*. It generate actual inputs from arbitraries, checks the predicate, and does the shrinking plus some reporting.  The other runners are mostly for checking your arbitratiries. For instance fc.sample that will generate a number of example input so you can see what you build. 


### Syntax
The syntax has a functional style of programming, (which might takes some getting used to if you are not familiair with it), but is pretty straight forward:
```ts
fc.assert(  //the runner
  fc.property(  
    arbitrary1, arbitrary2...., arbitraryN  //the arbitraries generated by fastcheck
    (arbitrary1, arbitrary2, ..., aribitraryN) => predicateTest)  //the predicate
)
```

With that out of the way, lets look at some examples of property based tests and some strategies to find good properties. 


### Simple statistics: Product function
A good function to start first is the product function from the [simple statistics library](https://simple-statistics.github.io/). The product function takes in an array of numbers and multiplies them all together. It looks pretty straight forward so the focus can be on getting to understand the framework better. Also, maths and logic is filled properties, so finding some should be straightforward:

By just harking back on your algebra lessons, or checking the [wikipedia](https://en.wikipedia.org/wiki/Multiplication#Properties), you find that any product with an odd number of negatives sign, must be negative, and positive in all other cases. That is, at least as long as there is not a zero involved. If there is a zero, the result must also be zero (which could also be a property, but I guess one example based unit test would be just as good). 

There are many others. But kets write a test that checks whether the product is negative when the number of inputs with a negative signs is odd (and positive otherwise). The plan is to build an arbitrary that returns an array of numbers, without any zeros in it. Then in the predicate, count the negative numbers in the array, do the multiplication, and check if it is either negative (when the number of signs is negative) or positive otherwise. So we are checking 2 properties in one test. 

It al needs to be wrapped in fc properties and assertions. And we need a test runner (i am using deno's baked in testing)

```ts
Deno.test({name:"product function",ignore:false}, async (t) => {
  
  #1:
  const integerArrayWithoutZero = ()=> fc.array(fc.integer(), {minLength:1}).filter(arr=>!(arr.includes(0)))

  await t.step("result is negative if number of entries with a neg signs is odd, pos if num neg signs is even", ()=>{
    fc.assert( #2
      fc.property( #3
        integerArrayWithoutZero(),
        arr =>{ 4#
          const numNegative = arr.filter(d=>d<0).length
          
          const result = stat.product(arr)

          if ( (numNegative % 2)!=0){
            assert.assertLess(result, 0)
          }else{
            assert.assertGreater(result, 0)
          }
        }
      ),{numRuns:10000} #2
    )
  })
  
  ...
```

- 1a) Lets start of by making an array of integers. *fc.array()* is the function we need to generate an array. It takes as argument a type you want in the array. `fc.array(fc.integer())` would simply generate an array of integers. The length of the array will be randomized by fastcheck, but the array function takes in a minLength and maxLength options, so it is easy to generate an array with a minlength of 1. 
- 1b) Next we need to rule out any zeros. We can do this with the *filter* function. It works like the standard js filter function: it takes in a predicate that returns true or false: filter will be called for each generated item: if false, it is filtered out.    
- 2) With the assert fastcheck will run the property 100 times (by default), It takes in as arguments the property function, and an optional config object. In the config you can for instance set the number of runs higher or lower.  
- 3) In the property function  you declare the arbitraries for which the property  must hold, and the predicate function itself. The predicate function must have the generated arbitraries as arguments. 
- 4) in the predicate function we simply count the number of negative signs, calculate the result using the product function from the simple statistics library(stat.product) and then assert it is either greater or less then 0. 

Running this (with deno test or any other test runner), it should  to pass. We can improve on this particular property by not just testing integers but any number (floats doubles integers are offered by fast-check). To generate one of those in an array (or in any other arbitrary) we can use the *oneOf* function: `fc.oneOf(fc.float(), fc.double(), fc.integer())`. Fastcheck will pick one at random at every call. Unlike integers, doubles will include infinity and Nan values by default, but in this test they make no sense, so we should exclude them.  Another improvement might be to do the filtering immediately on the generated number. It seems more efficient, since all generated numbers in an array are dropped. 

This is the improved arbitrary (without doubles):
```ts
  const numbersArray = ()=> fc.array(
    fc.oneof(fc.integer(), fc.float({noNaN:true, noDefaultInfinity:true})).filter(num=> num!==0),
    {minLength:1})
```


The next property is that the order of multiplication should not matter. The product of 1 big array should be the same as the product of the product of subslices of that array. Running this test will give some issues (not necessarily bugs), and is a good way to show some output from fastcheck. 


```ts
  await t.step("product of the product of 2 arrays, is the same as the product of the combined array",()=>{
    fc.assert(
      fc.property(
        integerArrayWithoutZero(),
        integerArrayWithoutZero(),
        (arr1,arr2)=>{
          const prodArr1 = stat.product(arr1)
          const prodArr2 = stat.product(arr2)
          assert.assertEquals(stat.product([...arr1,...arr2]), stat.product([prodArr1, prodArr2]))
        }
      )
    )
  })

```
So here we define a property tests that generates 2 arrays, and do the check best described by the code, and then expect the result to be equal. The output says it is not:

```bash
product function ... product of the product of 2 arrays, is the same as the product of the combined array => ./main_test.ts:450:11
error: Error: Property failed after 3 tests
{ seed: 1876754249, path: "2:0:0:0:0:0:0:2:0:0:0:0:3:3:0:0:0:0:5:0:1:2:3:3:3:3:3:0:0:2:3:0:0:0:4:0:1:0:0:0:2:1:2:3:3:3:3:0:0:0:0:0:0:0:0:0:1:0:0:0:0:0:0:0:0:0:0:0:2:2:0:0:0:0:0:0:0:0:0:1:1:1:4:2:2:4:2:0:10:14:3:3:9:3:3:3:8:2:2:4:7:2:3:5:2:3:2:5:4:5:7:10:5:5:5:3:3:2:2:13:5:4:4:2:3:2", endOnFailure: true }
Counterexample: [[9],[-242890315,75401657]]
Shrunk 125 time(s)
Got AssertionError: Values are not equal.

    [Diff] Actual / Expected

-   -164828989982267600
+   -164828989982267620

```
Apparently the order does matter for computers when you have very high and/or small numbers. 

The fastcheck library has shrunk to a very nice *counterexample* that shows the issue. (and the object with the seed,path etc can be used to 'replay' the failure).  Since this is more of a js/computer problem, we can make an alteration to only include numbers with a max of 3 decimals and limit the value so they do not get to big. (Now it matters if you use an array with only integers, or an array with integers and floats. With just integers the number gets to big, with floats its can get to small. But in both cases are due to a loss precision. (In the above example integers are used))

But this is an easy fix: the min max parameters for doubles / floats can be used to limit the generated arrays to only include smaller numbers. And we can then use the *map* function from fastcheck, to round any number to only have 3 decimals (also, you might need to use almostEquals in the assertion because there are small rounding differences): 

```ts
const arr = (range: number) =>
  fc.array(
    fc.oneof(
      fc.integer({ max: range, min: -range }),
      fc.float({ max: range, min: -range, noNaN: true, noDefaultInfinity: true })
        .map(d => Math.round(d * 1000) / 1000)
    ).filter(num => num !== 0)
    , { minLength: 1 })
```

In this examples you have seen it is pretty easy to get started with property based testing in fastcheck. There is plenty of option to tweak your arbitraries to your needs. You will need to do some work to build the right arbitraries because if you are like me,  the property will prove more specific then first thought or the function is working under less conditions then expected. But this just makes you think harder about when the tested function should work and explicates a lot more then an example based test. 


### Quickselect example

Next up is the quickselect function as offered by the same same simple statistics library. The quickselect functions will take a rank as input (k) and an array of numbers. It will then  re-arrange the array so that numbers smaller then k are in a consecutive range below that k, numbers bigger then k are in a range above the k and, the k-th ranking array item is in a guaranteed position. It is different from a sort, because the ranges below or above are not necesarrily in sorted order.  

for instance if you want the 5th lowest number in   [10,1,4,12,5,71,32,-1,-2], stat.quickselect(arr,4) will return [-2,1,4,-1,5,71,32,12,10] with the 4th index containing the 5th lowest number.


This example will show the first strategy: testing correctness. It is still a good property because the outcome seems difficult to calculate but easy to check. Also, it is a nice way to show how to generate arbitraries that use other arbitraries.

Since the rank and the length of the array both seem testworthy (they each by themself and in combination could cause errors), it makes sense to have them both generated by property based testing (instead of deriving one from the other). This means both generating an array of certain length and the rank (k), an positive integer that is smaller then the length of the array. 

So we need an array, like in the previous example. The length of the array will be randomized by fastcheck, but the array function takes in a minLength we have already seen. The minLength can guarantee that fastcheck can create any value for rank k without out of bound issues.  But this  means we need to generate the rank first. 

We want to write something like this, but then in a functional style: 
```ts
const rank = fc.nat()
const arr = fc.array(fc.integer, {minLenght: rank})
return [rank, arr]
```

To do that functionally, we need to use the *chain* function. This chain is what you need if you want to make consequtive arbitraries (arbitraries that are based of other ones): 
  'fc.nat().chain(k=>fc.array(fc.integer(), {minLength:k}))`

The arbirary fc.nat is randomly generated positive integer (the rank k) and used, by *chaining* it, to generate another array arbitrary. This however still has a problem, because we need to know in the test what the value of the rank is. That can be solved by saving the k in a *composite arbitrary*, for instance a tuple or a record.  Be aware that you then do need to wrap your passed along value as an *fc.constant*:

```ts
fc.nat().chain(k=>fc.tuple(fc.constant(k), fc.array(fc.integer(), {minLength:k})))
```

You can check some sample generated by this arbitrary by using the fc.sample function. It will generate some values so you can easily inspect and sanity check the results. 

```ts
fc.sample(fc.nat({ max: 100 }).chain((k) =>
          fc.tuple(fc.constant(k), fc.array(fc.integer(), { minLength: k + 1 }))
        ), {numRuns:10})
```


 
```ts
Deno.test({ name: "quickselect function", ignore: true }, async (t) => {
  
  await t.step("returns correct segmentation of array", () => {
    fc.assert(
      fc.property(
        fc.nat({ max: 100}).chain((k) =>
          fc.tuple(fc.constant(k), fc.array(fc.integer(), { minLength: k+1 }))
        ),
        ([k, arrRaw]) => {
          const arr = [...arrRaw] //1
          const sorted = arr.toSorted((a, b) => a - b);
          stat.quickselect(arr, k);
          
          assertEquals(sorted[k], arr[k]);
          assert.assert(arr.slice(0, k).every((d) => d <= arr[k]));
          assert.assert(arr.slice(k).every((d) => d >= arr[k]));
        },
      ),{endOnFailure:false} //2
    );
  });

  ...

})
```

1. it is important to copy any arbitrary (or just byref arbitraries) used in a predicate. Otherwise fc will get confused when doing the shrinking and displaying the counterexample, since it will use the modified array. Since quickselect modifies the array in place, copying is necessary. 

2. if you want to not shrink and find the best 'counterexample' you can disable shrinking by setting endOnFailure to true. (false as in the code is the default)


 Since the quickselect is one of those functions that does some calculation that is difficult to implement but very easy to check, the property based test is at its best. Defining some simple predicates installs a lot of confidence in the correctness.

Now using chain might come at the cost of less effective shrinking, so it is worth considering other options. One might be to just generate a random array and rank (nat), and then check if the rank <= arr.length. For that you can use filters (or fc.pre).  The downside of filtering is that a lot of generated values will be dropped, making the process less efficient (and stopping the run even if too many generated values are filtered out). 

This quickselect function has some issues is you start playing with the left and right parameters and they are too large (it will start inserting undefined). But this is not something I could catch in a property, and probably would be found pretty quickly with 'ordinary' testing. 


### Sample Correlation example

As a last example lets focus on the sample correlation function. The correlation is a measure in which 2 random variables move in a similar (linear) direction. The sample correlation function takes in 2 even lengths array and will return a number from -1 to 1, with -1 meaning perfect negative correlation, 0 no correlation and 1 perfect correlation. 


```ts
Deno.test({ name: "Sample Correlation function", ignore: false }, async (t) => {
  

  const numArbitrary = () =>  fc.oneof(
    fc.integer(),
    fc.float({ noDefaultInfinity: true, noNaN: true }),
  ).map(d=>Math.round(d*1000)/1000  );


  await t.step("correlation is always between -1 and 1", () => {
    fc.assert(fc.property(
      fc.integer({ min: 2, max: 2000 }).chain((n) =>
        fc.record({
          x: fc.array(numArbitrary(), { minLength: n, maxLength: n }),
          y: fc.array(numArbitrary(), { minLength: n, maxLength: n }),
        })
      ),
      ({ x, y }) => {
        fc.pre((new Set(x)).size > 1 && (new Set(y)).size > 1); //1
        const corr = stat.sampleCorrelation(x, y);
        assertLessOrEqual(
          corr,
          1.00000002, //2
          `sample correlation bigger then 1 (${corr})  for ${x}, ${y}`,
        );
        assertGreaterOrEqual(
          corr,
          -1.0000002, //2
          `sample correlation less then -1 (${corr})  for ${x}, ${y}`,
        );
      },
    ));
  });

  await t.step("arr is fully correlated with itself", () => {
    fc.assert(
      fc.property(fc.array(numArbitrary(), { minLength: 2 }), (arr) => {
        fc.pre((new Set(arr)).size > 1);
        const corr = stat.sampleCorrelation(arr, arr);
        assertAlmostEquals( //2
          corr,
          1,
          undefined,
          `correlation of arr with itself is not 1 but ${corr}`,
        );
      }),
      { numRuns: 400 },
    );
  });


  await t.step(
    "correlation between arr and arr *-1 = -1 if only unique entries",
    () => {
      fc.assert(
        fc.property(fc.uniqueArray(numArbitrary(), { minLength: 2 }), (arr) => {
          fc.pre((new Set(arr)).size > 1);
          const signSwitchedArr = arr.map((d) => d * -1);
          const corr = stat.sampleCorrelation(arr, signSwitchedArr);
          assertAlmostEquals(
            corr,
            -1,
            undefined,
            `correlation between ${arr} and ${signSwitchedArr} is not -1`,
          );
        }),
      );
    },
  );

  await t.step("correlation of x and y after linear transformation to x or y", ()=>{

    fc.assert(fc.property(  
      fc.integer({min:2, max:2000}).chain((n) =>
      fc.record({
        x: fc.array(numArbitrary(), { minLength: n, maxLength: n }),
        y: fc.array(numArbitrary(), { minLength: n, maxLength: n }),
      })),
      ({x,y})=>{
        fc.pre((new Set(x)).size > 1 && (new Set(y)).size > 1);
        const corXY = stat.sampleCorrelation(x,y)
        const corTrans = stat.sampleCorrelation(y.map(d=>d+3), x.map(d=>d*2.42))
        assertAlmostEquals(corXY, corTrans)
      }
    ))
  })

```

- #1 in stead of using fc.filter, you can also use fc.pre to filter out r in this case, skip some values. In this case for the properties to work, there most be more then 1 unique item in the array. 
- #2 you could say this is a bug. the function sometimes retunrs 1.0000002. To make it pass, the assertion uses slighly larger ranges then -1 to 1
- #3 similar to the first, the sample correlation function is not completely precise, which is very noticeable at 1 and -1

There are a lot of properties to think of. Implementing seems easy enough at first, but every one had to be formulated a bit more precise: as said before this is were you learn a lot about the sut. In this example however, the properties I implemented (could find and or think of) all feel somewhat indirect, they all check the boundaries (1, -1, sign swapping etc) but never an inbetween outcome directly. But it is important to remember that property based testing is not a replacement for example based testing.  


### Thoughts
#### Great 
Great for hard to calculate, easy to check type of problems (array sorting). Probably great for more difficult to oversee problems for which properties are a great sanity check. It does really make you think harder about what the object under test really does, from the inputs to the outputs to its characteristics.  It is one extra step to prevent some implicit assumption or bias to slip into the test cases you are defining or the code you are writing. 

#### Maybe as a default as random data generator
Testing with random data is a great way, especially if the sut is visual (ui component, graph). You might consider using fastcheck for that in stead of another faking library:  while doing pbt the arbitraries might already be set up to match some component / class or functions parameters, or some api test. You can just get a sample of one with the fc.sample runner (though some of the syntax is unnecessary if you are not going to shrink it)


#### Some problems
For some of the functions I found is hard to find properties that do not make you feel like you have not covered the important parts.  Just writing properties for known outcomes (like 1 for correlation of array with itself) feels somewhat laking. But is tested with a wider range of inputs then any example based unit test, with relative ease, so no need to frown about that too much I feel. More importantly, property based testing is not a substitute for unit /example based testing. Also it might be that different types of code offer a completely different experience. For instance writing pbt for more business logic type modules will probably have other difficulties and strong points.

Building the right arbitraries can be fiddly and takes some getting used too. Maybe again because of the example (stats library) there were some struggles with high precision numbers. This definitely finds bugs, though you can argue about the value of these bugs for some functions: does it matter the correlation is reported as 1.000002 instead of 1 ? 

You can also be blindsided by a property being true, but the results making no sense. The sum examples first property, was passing, but only with the second example did I realise that number was way to big or to small (You could argue the sign is still correct). While this is true for any form of testing, it might be easier to fall in this trap with pbt. Anyway, again, pbt is not a substitution for example based testing. 


In this post we focused on property based testing as an alternative to example driven testing. But fastcheck can be used for many more. Fastcheck also offers support for [model based testing](https://fast-check.dev/docs/advanced/model-based-testing/), [asynchronous testing](https://fast-check.dev/docs/advanced/race-conditions/), [prototype polution](https://fast-check.dev/blog/2023/09/21/detect-prototype-pollution-automatically/). So all in all a lot more to explore apart from these basic examples. 